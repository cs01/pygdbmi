<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.4" />
<title>pygdbmi.gdbcontroller API documentation</title>
<meta name="description" content="GdbController class to programatically run gdb and get structured output" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>pygdbmi.gdbcontroller</code> module</h1>
</header>
<section id="section-intro">
<p>GdbController class to programatically run gdb and get structured output</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;GdbController class to programatically run gdb and get structured output&#34;&#34;&#34;

from distutils.spawn import find_executable
import logging
import os
from pprint import pformat
from pygdbmi import gdbmiparser
import signal
import select
import subprocess
import sys
import time

try:  # py3
    from shlex import quote
except ImportError:  # py2
    from pipes import quote

PYTHON3 = sys.version_info.major == 3
DEFAULT_GDB_TIMEOUT_SEC = 1
DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC = 0.2
USING_WINDOWS = os.name == &#34;nt&#34;
if USING_WINDOWS:
    import msvcrt
    from ctypes import windll, byref, wintypes, WinError, POINTER
    from ctypes.wintypes import HANDLE, DWORD, BOOL
else:
    import fcntl

SIGNAL_NAME_TO_NUM = {}
for n in dir(signal):
    if n.startswith(&#34;SIG&#34;) and &#34;_&#34; not in n:
        SIGNAL_NAME_TO_NUM[n.upper()] = getattr(signal, n)

unicode = str if PYTHON3 else unicode  # noqa: F821


class NoGdbProcessError(ValueError):
    &#34;&#34;&#34;Raise when trying to interact with gdb subprocess, but it does not exist.
    It may have been killed and removed, or failed to initialize for some reason.&#34;&#34;&#34;

    pass


class GdbTimeoutError(ValueError):
    &#34;&#34;&#34;Raised when no response is recieved from gdb after the timeout has been triggered&#34;&#34;&#34;

    pass


class GdbController:
    &#34;&#34;&#34;
    Run gdb as a subprocess. Send commands and receive structured output.
    Create new object, along with a gdb subprocess

    Args:
        gdb_path (str): Command to run in shell to spawn new gdb subprocess
        gdb_args (list): Arguments to pass to shell when spawning new gdb subprocess
        time_to_check_for_additional_output_sec (float): When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If &lt;= 0, full timeout time is used.
        rr (bool): Use the `rr replay` command instead of `gdb`. See rr-project.org for more info.
        verbose (bool): Print verbose output if True
    Returns:
        New GdbController object
    &#34;&#34;&#34;

    def __init__(
        self,
        gdb_path=&#34;gdb&#34;,
        gdb_args=None,
        time_to_check_for_additional_output_sec=DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC,
        rr=False,
        verbose=False,
    ):
        if gdb_args is None:
            default_gdb_args = [&#34;--nx&#34;, &#34;--quiet&#34;, &#34;--interpreter=mi2&#34;]
            gdb_args = default_gdb_args

        self.verbose = verbose
        self.abs_gdb_path = None  # abs path to gdb executable
        self.cmd = []  # the shell command to run gdb
        self.time_to_check_for_additional_output_sec = (
            time_to_check_for_additional_output_sec
        )
        self.gdb_process = None
        self._allow_overwrite_timeout_times = (
            self.time_to_check_for_additional_output_sec &gt; 0
        )

        if rr:
            self.cmd = [&#34;rr&#34;, &#34;replay&#34;] + gdb_args

        else:
            if not gdb_path:
                raise ValueError(&#34;a valid path to gdb must be specified&#34;)

            else:
                abs_gdb_path = find_executable(gdb_path)
                if abs_gdb_path is None:
                    raise ValueError(
                        &#39;gdb executable could not be resolved from &#34;%s&#34;&#39; % gdb_path
                    )

                else:
                    self.abs_gdb_path = abs_gdb_path
            self.cmd = [self.abs_gdb_path] + gdb_args

        self._attach_logger(verbose)
        self.spawn_new_gdb_subprocess()

    def _attach_logger(self, verbose):
        handler = logging.StreamHandler()
        handler.setFormatter(logging.Formatter(&#34;%(message)s&#34;))
        unique_number = time.time()
        self.logger = logging.getLogger(__name__ + &#34;.&#34; + str(unique_number))
        self.logger.propagate = False
        if verbose:
            level = logging.DEBUG
        else:
            level = logging.ERROR
        self.logger.setLevel(level)
        self.logger.addHandler(handler)

    def get_subprocess_cmd(self):
        &#34;&#34;&#34;Returns the shell-escaped string used to invoke the gdb subprocess.
        This is a string that can be executed directly in a shell.
        &#34;&#34;&#34;
        return &#34; &#34;.join(quote(c) for c in self.cmd)

    def spawn_new_gdb_subprocess(self):
        &#34;&#34;&#34;Spawn a new gdb subprocess with the arguments supplied to the object
        during initialization. If gdb subprocess already exists, terminate it before
        spanwing a new one.
        Return int: gdb process id
        &#34;&#34;&#34;
        if self.gdb_process:
            self.logger.debug(
                &#34;Killing current gdb subprocess (pid %d)&#34; % self.gdb_process.pid
            )
            self.exit()

        self.logger.debug(&#39;Launching gdb: &#34;%s&#34;&#39; % &#34; &#34;.join(self.cmd))

        # Use pipes to the standard streams
        self.gdb_process = subprocess.Popen(
            self.cmd,
            shell=False,
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE,
            stderr=subprocess.PIPE,
            bufsize=0,
        )

        _make_non_blocking(self.gdb_process.stdout)
        _make_non_blocking(self.gdb_process.stderr)

        # save file numbers for use later
        self.stdout_fileno = self.gdb_process.stdout.fileno()
        self.stderr_fileno = self.gdb_process.stderr.fileno()
        self.stdin_fileno = self.gdb_process.stdin.fileno()

        self.read_list = [self.stdout_fileno, self.stderr_fileno]
        self.write_list = [self.stdin_fileno]

        # string buffers for unifinished gdb output
        self._incomplete_output = {&#34;stdout&#34;: None, &#34;stderr&#34;: None}
        return self.gdb_process.pid

    def verify_valid_gdb_subprocess(self):
        &#34;&#34;&#34;Verify there is a process object, and that it is still running.
        Raise NoGdbProcessError if either of the above are not true.&#34;&#34;&#34;
        if not self.gdb_process:
            raise NoGdbProcessError(&#34;gdb process is not attached&#34;)

        elif self.gdb_process.poll() is not None:
            raise NoGdbProcessError(
                &#34;gdb process has already finished with return code: %s&#34;
                % str(self.gdb_process.poll())
            )

    def write(
        self,
        mi_cmd_to_write,
        timeout_sec=DEFAULT_GDB_TIMEOUT_SEC,
        raise_error_on_timeout=True,
        read_response=True,
    ):
        &#34;&#34;&#34;Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec.

        Args:
            mi_cmd_to_write (str or list): String to write to gdb. If list, it is joined by newlines.
            timeout_sec (float): Maximum number of seconds to wait for response before exiting. Must be &gt;= 0.
            raise_error_on_timeout (bool): If read_response is True, raise error if no response is received
            read_response (bool): Block and read response. If there is a separate thread running,
            this can be false, and the reading thread read the output.
        Returns:
            List of parsed gdb responses if read_response is True, otherwise []
        Raises:
            NoGdbProcessError if there is no gdb subprocess running
            TypeError if mi_cmd_to_write is not valid
        &#34;&#34;&#34;
        self.verify_valid_gdb_subprocess()
        if timeout_sec &lt; 0:
            self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
            timeout_sec = 0

        # Ensure proper type of the mi command
        if type(mi_cmd_to_write) in [str, unicode]:
            pass
        elif type(mi_cmd_to_write) == list:
            mi_cmd_to_write = &#34;\n&#34;.join(mi_cmd_to_write)
        else:
            raise TypeError(
                &#34;The gdb mi command must a be str or list. Got &#34;
                + str(type(mi_cmd_to_write))
            )

        self.logger.debug(&#34;writing: %s&#34;, mi_cmd_to_write)

        if not mi_cmd_to_write.endswith(&#34;\n&#34;):
            mi_cmd_to_write_nl = mi_cmd_to_write + &#34;\n&#34;
        else:
            mi_cmd_to_write_nl = mi_cmd_to_write

        if USING_WINDOWS:
            # select not implemented in windows for pipes
            # assume it&#39;s always ready
            outputready = [self.stdin_fileno]
        else:
            _, outputready, _ = select.select([], self.write_list, [], timeout_sec)
        for fileno in outputready:
            if fileno == self.stdin_fileno:
                # ready to write
                self.gdb_process.stdin.write(mi_cmd_to_write_nl.encode())
                # don&#39;t forget to flush for Python3, otherwise gdb won&#39;t realize there is data
                # to evaluate, and we won&#39;t get a response
                self.gdb_process.stdin.flush()
            else:
                self.logger.error(&#34;got unexpected fileno %d&#34; % fileno)

        if read_response is True:
            return self.get_gdb_response(
                timeout_sec=timeout_sec, raise_error_on_timeout=raise_error_on_timeout
            )

        else:
            return []

    def get_gdb_response(
        self, timeout_sec=DEFAULT_GDB_TIMEOUT_SEC, raise_error_on_timeout=True
    ):
        &#34;&#34;&#34;Get response from GDB, and block while doing so. If GDB does not have any response ready to be read
        by timeout_sec, an exception is raised.

        Args:
            timeout_sec (float): Maximum time to wait for reponse. Must be &gt;= 0. Will return after
            raise_error_on_timeout (bool): Whether an exception should be raised if no response was found
            after timeout_sec

        Returns:
            List of parsed GDB responses, returned from gdbmiparser.parse_response, with the
            additional key &#39;stream&#39; which is either &#39;stdout&#39; or &#39;stderr&#39;

        Raises:
            GdbTimeoutError if response is not received within timeout_sec
            ValueError if select returned unexpected file number
            NoGdbProcessError if there is no gdb subprocess running
        &#34;&#34;&#34;

        self.verify_valid_gdb_subprocess()
        if timeout_sec &lt; 0:
            self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
            timeout_sec = 0

        if USING_WINDOWS:
            retval = self._get_responses_windows(timeout_sec)
        else:
            retval = self._get_responses_unix(timeout_sec)

        if not retval and raise_error_on_timeout:
            raise GdbTimeoutError(
                &#34;Did not get response from gdb after %s seconds&#34; % timeout_sec
            )

        else:
            return retval

    def _get_responses_windows(self, timeout_sec):
        &#34;&#34;&#34;Get responses on windows. Assume no support for select and use a while loop.&#34;&#34;&#34;
        timeout_time_sec = time.time() + timeout_sec
        responses = []
        while True:
            try:
                self.gdb_process.stdout.flush()
                if PYTHON3:
                    raw_output = self.gdb_process.stdout.readline().replace(
                        b&#34;\r&#34;, b&#34;\n&#34;
                    )
                else:
                    raw_output = self.gdb_process.stdout.read().replace(b&#34;\r&#34;, b&#34;\n&#34;)
                responses += self._get_responses_list(raw_output, &#34;stdout&#34;)
            except IOError:
                pass

            try:
                self.gdb_process.stderr.flush()
                if PYTHON3:
                    raw_output = self.gdb_process.stderr.readline().replace(
                        b&#34;\r&#34;, b&#34;\n&#34;
                    )
                else:
                    raw_output = self.gdb_process.stderr.read().replace(b&#34;\r&#34;, b&#34;\n&#34;)
                responses += self._get_responses_list(raw_output, &#34;stderr&#34;)
            except IOError:
                pass

            if time.time() &gt; timeout_time_sec:
                break

        return responses

    def _get_responses_unix(self, timeout_sec):
        &#34;&#34;&#34;Get responses on unix-like system. Use select to wait for output.&#34;&#34;&#34;
        timeout_time_sec = time.time() + timeout_sec
        responses = []
        while True:
            select_timeout = timeout_time_sec - time.time()
            # I prefer to not pass a negative value to select
            if select_timeout &lt;= 0:
                select_timeout = 0
            events, _, _ = select.select(self.read_list, [], [], select_timeout)
            responses_list = None  # to avoid infinite loop if using Python 2
            try:
                for fileno in events:
                    # new data is ready to read
                    if fileno == self.stdout_fileno:
                        self.gdb_process.stdout.flush()
                        raw_output = self.gdb_process.stdout.read()
                        stream = &#34;stdout&#34;

                    elif fileno == self.stderr_fileno:
                        self.gdb_process.stderr.flush()
                        raw_output = self.gdb_process.stderr.read()
                        stream = &#34;stderr&#34;

                    else:
                        raise ValueError(
                            &#34;Developer error. Got unexpected file number %d&#34; % fileno
                        )

                    responses_list = self._get_responses_list(raw_output, stream)
                    responses += responses_list

            except IOError:  # only occurs in python 2.7
                pass

            if timeout_sec == 0:  # just exit immediately
                break

            elif responses_list and self._allow_overwrite_timeout_times:
                # update timeout time to potentially be closer to now to avoid lengthy wait times when nothing is being output by gdb
                timeout_time_sec = min(
                    time.time() + self.time_to_check_for_additional_output_sec,
                    timeout_time_sec,
                )

            elif time.time() &gt; timeout_time_sec:
                break

        return responses

    def _get_responses_list(self, raw_output, stream):
        &#34;&#34;&#34;Get parsed response list from string output
        Args:
            raw_output (unicode): gdb output to parse
            stream (str): either stdout or stderr
        &#34;&#34;&#34;
        responses = []

        raw_output, self._incomplete_output[stream] = _buffer_incomplete_responses(
            raw_output, self._incomplete_output.get(stream)
        )

        if not raw_output:
            return responses

        response_list = list(
            filter(lambda x: x, raw_output.decode(errors=&#34;replace&#34;).split(&#34;\n&#34;))
        )  # remove blank lines

        # parse each response from gdb into a dict, and store in a list
        for response in response_list:
            if gdbmiparser.response_is_finished(response):
                pass
            else:
                parsed_response = gdbmiparser.parse_response(response)
                parsed_response[&#34;stream&#34;] = stream

                self.logger.debug(&#34;%s&#34;, pformat(parsed_response))

                responses.append(parsed_response)

        return responses

    def send_signal_to_gdb(self, signal_input):
        &#34;&#34;&#34;Send signal name (case insensitive) or number to gdb subprocess
        gdbmi.send_signal_to_gdb(2)  # valid
        gdbmi.send_signal_to_gdb(&#39;sigint&#39;)  # also valid
        gdbmi.send_signal_to_gdb(&#39;SIGINT&#39;)  # also valid

        raises ValueError if signal_input is invalie
        raises NoGdbProcessError if there is no gdb process to send a signal to
        &#34;&#34;&#34;
        try:
            signal = int(signal_input)
        except Exception:
            signal = SIGNAL_NAME_TO_NUM.get(signal_input.upper())

        if not signal:
            raise ValueError(
                &#39;Could not find signal corresponding to &#34;%s&#34;&#39; % str(signal)
            )

        if self.gdb_process:
            os.kill(self.gdb_process.pid, signal)
        else:
            raise NoGdbProcessError(
                &#34;Cannot send signal to gdb process because no process exists.&#34;
            )

    def interrupt_gdb(self):
        &#34;&#34;&#34;Send SIGINT (interrupt signal) to the gdb subprocess&#34;&#34;&#34;
        self.send_signal_to_gdb(&#34;SIGINT&#34;)

    def exit(self):
        &#34;&#34;&#34;Terminate gdb process
        Returns: None&#34;&#34;&#34;
        if self.gdb_process:
            self.gdb_process.terminate()
            self.gdb_process.communicate()
        self.gdb_process = None
        return None


def _buffer_incomplete_responses(raw_output, buf):
    &#34;&#34;&#34;It is possible for some of gdb&#39;s output to be read before it completely finished its response.
    In that case, a partial mi response was read, which cannot be parsed into structured data.
    We want to ALWAYS parse complete mi records. To do this, we store a buffer of gdb&#39;s
    output if the output did not end in a newline.

    Args:
        raw_output: Contents of the gdb mi output
        buf (str): Buffered gdb response from the past. This is incomplete and needs to be prepended to
        gdb&#39;s next output.

    Returns:
        (raw_output, buf)
    &#34;&#34;&#34;

    if raw_output:
        if buf:
            # concatenate buffer and new output
            raw_output = b&#34;&#34;.join([buf, raw_output])
            buf = None

        if b&#34;\n&#34; not in raw_output:
            # newline was not found, so assume output is incomplete and store in buffer
            buf = raw_output
            raw_output = None

        elif not raw_output.endswith(b&#34;\n&#34;):
            # raw output doesn&#39;t end in a newline, so store everything after the last newline (if anything)
            # in the buffer, and parse everything before it
            remainder_offset = raw_output.rindex(b&#34;\n&#34;) + 1
            buf = raw_output[remainder_offset:]
            raw_output = raw_output[:remainder_offset]

    return (raw_output, buf)


def _make_non_blocking(file_obj):
    &#34;&#34;&#34;make file object non-blocking
    Windows doesn&#39;t have the fcntl module, but someone on
    stack overflow supplied this code as an answer, and it works
    http://stackoverflow.com/a/34504971/2893090&#34;&#34;&#34;

    if USING_WINDOWS:
        LPDWORD = POINTER(DWORD)
        PIPE_NOWAIT = wintypes.DWORD(0x00000001)

        SetNamedPipeHandleState = windll.kernel32.SetNamedPipeHandleState
        SetNamedPipeHandleState.argtypes = [HANDLE, LPDWORD, LPDWORD, LPDWORD]
        SetNamedPipeHandleState.restype = BOOL

        h = msvcrt.get_osfhandle(file_obj.fileno())

        res = windll.kernel32.SetNamedPipeHandleState(h, byref(PIPE_NOWAIT), None, None)
        if res == 0:
            raise ValueError(WinError())

    else:
        # Set the file status flag (F_SETFL) on the pipes to be non-blocking
        # so we can attempt to read from a pipe with no new data without locking
        # the program up
        fcntl.fcntl(file_obj, fcntl.F_SETFL, os.O_NONBLOCK)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pygdbmi.gdbcontroller.GdbController"><code class="flex name class">
<span>class <span class="ident">GdbController</span></span>
</code></dt>
<dd>
<section class="desc"><p>Run gdb as a subprocess. Send commands and receive structured output.
Create new object, along with a gdb subprocess</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdb_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Command to run in shell to spawn new gdb subprocess</dd>
<dt><strong><code>gdb_args</code></strong> :&ensp;<code>list</code></dt>
<dd>Arguments to pass to shell when spawning new gdb subprocess</dd>
<dt><strong><code>time_to_check_for_additional_output_sec</code></strong> :&ensp;<code>float</code></dt>
<dd>When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If &lt;= 0, full timeout time is used.</dd>
<dt><strong><code>rr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Use the <code>rr replay</code> command instead of <code>gdb</code>. See rr-project.org for more info.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Print verbose output if True</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New GdbController object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class GdbController:
    &#34;&#34;&#34;
    Run gdb as a subprocess. Send commands and receive structured output.
    Create new object, along with a gdb subprocess

    Args:
        gdb_path (str): Command to run in shell to spawn new gdb subprocess
        gdb_args (list): Arguments to pass to shell when spawning new gdb subprocess
        time_to_check_for_additional_output_sec (float): When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If &lt;= 0, full timeout time is used.
        rr (bool): Use the `rr replay` command instead of `gdb`. See rr-project.org for more info.
        verbose (bool): Print verbose output if True
    Returns:
        New GdbController object
    &#34;&#34;&#34;

    def __init__(
        self,
        gdb_path=&#34;gdb&#34;,
        gdb_args=None,
        time_to_check_for_additional_output_sec=DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC,
        rr=False,
        verbose=False,
    ):
        if gdb_args is None:
            default_gdb_args = [&#34;--nx&#34;, &#34;--quiet&#34;, &#34;--interpreter=mi2&#34;]
            gdb_args = default_gdb_args

        self.verbose = verbose
        self.abs_gdb_path = None  # abs path to gdb executable
        self.cmd = []  # the shell command to run gdb
        self.time_to_check_for_additional_output_sec = (
            time_to_check_for_additional_output_sec
        )
        self.gdb_process = None
        self._allow_overwrite_timeout_times = (
            self.time_to_check_for_additional_output_sec &gt; 0
        )

        if rr:
            self.cmd = [&#34;rr&#34;, &#34;replay&#34;] + gdb_args

        else:
            if not gdb_path:
                raise ValueError(&#34;a valid path to gdb must be specified&#34;)

            else:
                abs_gdb_path = find_executable(gdb_path)
                if abs_gdb_path is None:
                    raise ValueError(
                        &#39;gdb executable could not be resolved from &#34;%s&#34;&#39; % gdb_path
                    )

                else:
                    self.abs_gdb_path = abs_gdb_path
            self.cmd = [self.abs_gdb_path] + gdb_args

        self._attach_logger(verbose)
        self.spawn_new_gdb_subprocess()

    def _attach_logger(self, verbose):
        handler = logging.StreamHandler()
        handler.setFormatter(logging.Formatter(&#34;%(message)s&#34;))
        unique_number = time.time()
        self.logger = logging.getLogger(__name__ + &#34;.&#34; + str(unique_number))
        self.logger.propagate = False
        if verbose:
            level = logging.DEBUG
        else:
            level = logging.ERROR
        self.logger.setLevel(level)
        self.logger.addHandler(handler)

    def get_subprocess_cmd(self):
        &#34;&#34;&#34;Returns the shell-escaped string used to invoke the gdb subprocess.
        This is a string that can be executed directly in a shell.
        &#34;&#34;&#34;
        return &#34; &#34;.join(quote(c) for c in self.cmd)

    def spawn_new_gdb_subprocess(self):
        &#34;&#34;&#34;Spawn a new gdb subprocess with the arguments supplied to the object
        during initialization. If gdb subprocess already exists, terminate it before
        spanwing a new one.
        Return int: gdb process id
        &#34;&#34;&#34;
        if self.gdb_process:
            self.logger.debug(
                &#34;Killing current gdb subprocess (pid %d)&#34; % self.gdb_process.pid
            )
            self.exit()

        self.logger.debug(&#39;Launching gdb: &#34;%s&#34;&#39; % &#34; &#34;.join(self.cmd))

        # Use pipes to the standard streams
        self.gdb_process = subprocess.Popen(
            self.cmd,
            shell=False,
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE,
            stderr=subprocess.PIPE,
            bufsize=0,
        )

        _make_non_blocking(self.gdb_process.stdout)
        _make_non_blocking(self.gdb_process.stderr)

        # save file numbers for use later
        self.stdout_fileno = self.gdb_process.stdout.fileno()
        self.stderr_fileno = self.gdb_process.stderr.fileno()
        self.stdin_fileno = self.gdb_process.stdin.fileno()

        self.read_list = [self.stdout_fileno, self.stderr_fileno]
        self.write_list = [self.stdin_fileno]

        # string buffers for unifinished gdb output
        self._incomplete_output = {&#34;stdout&#34;: None, &#34;stderr&#34;: None}
        return self.gdb_process.pid

    def verify_valid_gdb_subprocess(self):
        &#34;&#34;&#34;Verify there is a process object, and that it is still running.
        Raise NoGdbProcessError if either of the above are not true.&#34;&#34;&#34;
        if not self.gdb_process:
            raise NoGdbProcessError(&#34;gdb process is not attached&#34;)

        elif self.gdb_process.poll() is not None:
            raise NoGdbProcessError(
                &#34;gdb process has already finished with return code: %s&#34;
                % str(self.gdb_process.poll())
            )

    def write(
        self,
        mi_cmd_to_write,
        timeout_sec=DEFAULT_GDB_TIMEOUT_SEC,
        raise_error_on_timeout=True,
        read_response=True,
    ):
        &#34;&#34;&#34;Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec.

        Args:
            mi_cmd_to_write (str or list): String to write to gdb. If list, it is joined by newlines.
            timeout_sec (float): Maximum number of seconds to wait for response before exiting. Must be &gt;= 0.
            raise_error_on_timeout (bool): If read_response is True, raise error if no response is received
            read_response (bool): Block and read response. If there is a separate thread running,
            this can be false, and the reading thread read the output.
        Returns:
            List of parsed gdb responses if read_response is True, otherwise []
        Raises:
            NoGdbProcessError if there is no gdb subprocess running
            TypeError if mi_cmd_to_write is not valid
        &#34;&#34;&#34;
        self.verify_valid_gdb_subprocess()
        if timeout_sec &lt; 0:
            self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
            timeout_sec = 0

        # Ensure proper type of the mi command
        if type(mi_cmd_to_write) in [str, unicode]:
            pass
        elif type(mi_cmd_to_write) == list:
            mi_cmd_to_write = &#34;\n&#34;.join(mi_cmd_to_write)
        else:
            raise TypeError(
                &#34;The gdb mi command must a be str or list. Got &#34;
                + str(type(mi_cmd_to_write))
            )

        self.logger.debug(&#34;writing: %s&#34;, mi_cmd_to_write)

        if not mi_cmd_to_write.endswith(&#34;\n&#34;):
            mi_cmd_to_write_nl = mi_cmd_to_write + &#34;\n&#34;
        else:
            mi_cmd_to_write_nl = mi_cmd_to_write

        if USING_WINDOWS:
            # select not implemented in windows for pipes
            # assume it&#39;s always ready
            outputready = [self.stdin_fileno]
        else:
            _, outputready, _ = select.select([], self.write_list, [], timeout_sec)
        for fileno in outputready:
            if fileno == self.stdin_fileno:
                # ready to write
                self.gdb_process.stdin.write(mi_cmd_to_write_nl.encode())
                # don&#39;t forget to flush for Python3, otherwise gdb won&#39;t realize there is data
                # to evaluate, and we won&#39;t get a response
                self.gdb_process.stdin.flush()
            else:
                self.logger.error(&#34;got unexpected fileno %d&#34; % fileno)

        if read_response is True:
            return self.get_gdb_response(
                timeout_sec=timeout_sec, raise_error_on_timeout=raise_error_on_timeout
            )

        else:
            return []

    def get_gdb_response(
        self, timeout_sec=DEFAULT_GDB_TIMEOUT_SEC, raise_error_on_timeout=True
    ):
        &#34;&#34;&#34;Get response from GDB, and block while doing so. If GDB does not have any response ready to be read
        by timeout_sec, an exception is raised.

        Args:
            timeout_sec (float): Maximum time to wait for reponse. Must be &gt;= 0. Will return after
            raise_error_on_timeout (bool): Whether an exception should be raised if no response was found
            after timeout_sec

        Returns:
            List of parsed GDB responses, returned from gdbmiparser.parse_response, with the
            additional key &#39;stream&#39; which is either &#39;stdout&#39; or &#39;stderr&#39;

        Raises:
            GdbTimeoutError if response is not received within timeout_sec
            ValueError if select returned unexpected file number
            NoGdbProcessError if there is no gdb subprocess running
        &#34;&#34;&#34;

        self.verify_valid_gdb_subprocess()
        if timeout_sec &lt; 0:
            self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
            timeout_sec = 0

        if USING_WINDOWS:
            retval = self._get_responses_windows(timeout_sec)
        else:
            retval = self._get_responses_unix(timeout_sec)

        if not retval and raise_error_on_timeout:
            raise GdbTimeoutError(
                &#34;Did not get response from gdb after %s seconds&#34; % timeout_sec
            )

        else:
            return retval

    def _get_responses_windows(self, timeout_sec):
        &#34;&#34;&#34;Get responses on windows. Assume no support for select and use a while loop.&#34;&#34;&#34;
        timeout_time_sec = time.time() + timeout_sec
        responses = []
        while True:
            try:
                self.gdb_process.stdout.flush()
                if PYTHON3:
                    raw_output = self.gdb_process.stdout.readline().replace(
                        b&#34;\r&#34;, b&#34;\n&#34;
                    )
                else:
                    raw_output = self.gdb_process.stdout.read().replace(b&#34;\r&#34;, b&#34;\n&#34;)
                responses += self._get_responses_list(raw_output, &#34;stdout&#34;)
            except IOError:
                pass

            try:
                self.gdb_process.stderr.flush()
                if PYTHON3:
                    raw_output = self.gdb_process.stderr.readline().replace(
                        b&#34;\r&#34;, b&#34;\n&#34;
                    )
                else:
                    raw_output = self.gdb_process.stderr.read().replace(b&#34;\r&#34;, b&#34;\n&#34;)
                responses += self._get_responses_list(raw_output, &#34;stderr&#34;)
            except IOError:
                pass

            if time.time() &gt; timeout_time_sec:
                break

        return responses

    def _get_responses_unix(self, timeout_sec):
        &#34;&#34;&#34;Get responses on unix-like system. Use select to wait for output.&#34;&#34;&#34;
        timeout_time_sec = time.time() + timeout_sec
        responses = []
        while True:
            select_timeout = timeout_time_sec - time.time()
            # I prefer to not pass a negative value to select
            if select_timeout &lt;= 0:
                select_timeout = 0
            events, _, _ = select.select(self.read_list, [], [], select_timeout)
            responses_list = None  # to avoid infinite loop if using Python 2
            try:
                for fileno in events:
                    # new data is ready to read
                    if fileno == self.stdout_fileno:
                        self.gdb_process.stdout.flush()
                        raw_output = self.gdb_process.stdout.read()
                        stream = &#34;stdout&#34;

                    elif fileno == self.stderr_fileno:
                        self.gdb_process.stderr.flush()
                        raw_output = self.gdb_process.stderr.read()
                        stream = &#34;stderr&#34;

                    else:
                        raise ValueError(
                            &#34;Developer error. Got unexpected file number %d&#34; % fileno
                        )

                    responses_list = self._get_responses_list(raw_output, stream)
                    responses += responses_list

            except IOError:  # only occurs in python 2.7
                pass

            if timeout_sec == 0:  # just exit immediately
                break

            elif responses_list and self._allow_overwrite_timeout_times:
                # update timeout time to potentially be closer to now to avoid lengthy wait times when nothing is being output by gdb
                timeout_time_sec = min(
                    time.time() + self.time_to_check_for_additional_output_sec,
                    timeout_time_sec,
                )

            elif time.time() &gt; timeout_time_sec:
                break

        return responses

    def _get_responses_list(self, raw_output, stream):
        &#34;&#34;&#34;Get parsed response list from string output
        Args:
            raw_output (unicode): gdb output to parse
            stream (str): either stdout or stderr
        &#34;&#34;&#34;
        responses = []

        raw_output, self._incomplete_output[stream] = _buffer_incomplete_responses(
            raw_output, self._incomplete_output.get(stream)
        )

        if not raw_output:
            return responses

        response_list = list(
            filter(lambda x: x, raw_output.decode(errors=&#34;replace&#34;).split(&#34;\n&#34;))
        )  # remove blank lines

        # parse each response from gdb into a dict, and store in a list
        for response in response_list:
            if gdbmiparser.response_is_finished(response):
                pass
            else:
                parsed_response = gdbmiparser.parse_response(response)
                parsed_response[&#34;stream&#34;] = stream

                self.logger.debug(&#34;%s&#34;, pformat(parsed_response))

                responses.append(parsed_response)

        return responses

    def send_signal_to_gdb(self, signal_input):
        &#34;&#34;&#34;Send signal name (case insensitive) or number to gdb subprocess
        gdbmi.send_signal_to_gdb(2)  # valid
        gdbmi.send_signal_to_gdb(&#39;sigint&#39;)  # also valid
        gdbmi.send_signal_to_gdb(&#39;SIGINT&#39;)  # also valid

        raises ValueError if signal_input is invalie
        raises NoGdbProcessError if there is no gdb process to send a signal to
        &#34;&#34;&#34;
        try:
            signal = int(signal_input)
        except Exception:
            signal = SIGNAL_NAME_TO_NUM.get(signal_input.upper())

        if not signal:
            raise ValueError(
                &#39;Could not find signal corresponding to &#34;%s&#34;&#39; % str(signal)
            )

        if self.gdb_process:
            os.kill(self.gdb_process.pid, signal)
        else:
            raise NoGdbProcessError(
                &#34;Cannot send signal to gdb process because no process exists.&#34;
            )

    def interrupt_gdb(self):
        &#34;&#34;&#34;Send SIGINT (interrupt signal) to the gdb subprocess&#34;&#34;&#34;
        self.send_signal_to_gdb(&#34;SIGINT&#34;)

    def exit(self):
        &#34;&#34;&#34;Terminate gdb process
        Returns: None&#34;&#34;&#34;
        if self.gdb_process:
            self.gdb_process.terminate()
            self.gdb_process.communicate()
        self.gdb_process = None
        return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pygdbmi.gdbcontroller.GdbController.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, gdb_path=&#39;gdb&#39;, gdb_args=None, time_to_check_for_additional_output_sec=0.2, rr=False, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize self.
See help(type(self)) for accurate signature.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(
    self,
    gdb_path=&#34;gdb&#34;,
    gdb_args=None,
    time_to_check_for_additional_output_sec=DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC,
    rr=False,
    verbose=False,
):
    if gdb_args is None:
        default_gdb_args = [&#34;--nx&#34;, &#34;--quiet&#34;, &#34;--interpreter=mi2&#34;]
        gdb_args = default_gdb_args

    self.verbose = verbose
    self.abs_gdb_path = None  # abs path to gdb executable
    self.cmd = []  # the shell command to run gdb
    self.time_to_check_for_additional_output_sec = (
        time_to_check_for_additional_output_sec
    )
    self.gdb_process = None
    self._allow_overwrite_timeout_times = (
        self.time_to_check_for_additional_output_sec &gt; 0
    )

    if rr:
        self.cmd = [&#34;rr&#34;, &#34;replay&#34;] + gdb_args

    else:
        if not gdb_path:
            raise ValueError(&#34;a valid path to gdb must be specified&#34;)

        else:
            abs_gdb_path = find_executable(gdb_path)
            if abs_gdb_path is None:
                raise ValueError(
                    &#39;gdb executable could not be resolved from &#34;%s&#34;&#39; % gdb_path
                )

            else:
                self.abs_gdb_path = abs_gdb_path
        self.cmd = [self.abs_gdb_path] + gdb_args

    self._attach_logger(verbose)
    self.spawn_new_gdb_subprocess()</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.exit"><code class="name flex">
<span>def <span class="ident">exit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt>Terminate gdb process</dt>
<dt><strong><code>Returns</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exit(self):
    &#34;&#34;&#34;Terminate gdb process
    Returns: None&#34;&#34;&#34;
    if self.gdb_process:
        self.gdb_process.terminate()
        self.gdb_process.communicate()
    self.gdb_process = None
    return None</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.get_gdb_response"><code class="name flex">
<span>def <span class="ident">get_gdb_response</span></span>(<span>self, timeout_sec=1, raise_error_on_timeout=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Get response from GDB, and block while doing so. If GDB does not have any response ready to be read
by timeout_sec, an exception is raised.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout_sec</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum time to wait for reponse. Must be &gt;= 0. Will return after</dd>
<dt><strong><code>raise_error_on_timeout</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether an exception should be raised if no response was found</dd>
</dl>
<p>after timeout_sec</p>
<h2 id="returns">Returns</h2>
<p>List of parsed GDB responses, returned from gdbmiparser.parse_response, with the
additional key 'stream' which is either 'stdout' or 'stderr'</p>
<h2 id="raises">Raises</h2>
<p>GdbTimeoutError if response is not received within timeout_sec
ValueError if select returned unexpected file number
NoGdbProcessError if there is no gdb subprocess running</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_gdb_response(
    self, timeout_sec=DEFAULT_GDB_TIMEOUT_SEC, raise_error_on_timeout=True
):
    &#34;&#34;&#34;Get response from GDB, and block while doing so. If GDB does not have any response ready to be read
    by timeout_sec, an exception is raised.

    Args:
        timeout_sec (float): Maximum time to wait for reponse. Must be &gt;= 0. Will return after
        raise_error_on_timeout (bool): Whether an exception should be raised if no response was found
        after timeout_sec

    Returns:
        List of parsed GDB responses, returned from gdbmiparser.parse_response, with the
        additional key &#39;stream&#39; which is either &#39;stdout&#39; or &#39;stderr&#39;

    Raises:
        GdbTimeoutError if response is not received within timeout_sec
        ValueError if select returned unexpected file number
        NoGdbProcessError if there is no gdb subprocess running
    &#34;&#34;&#34;

    self.verify_valid_gdb_subprocess()
    if timeout_sec &lt; 0:
        self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
        timeout_sec = 0

    if USING_WINDOWS:
        retval = self._get_responses_windows(timeout_sec)
    else:
        retval = self._get_responses_unix(timeout_sec)

    if not retval and raise_error_on_timeout:
        raise GdbTimeoutError(
            &#34;Did not get response from gdb after %s seconds&#34; % timeout_sec
        )

    else:
        return retval</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.get_subprocess_cmd"><code class="name flex">
<span>def <span class="ident">get_subprocess_cmd</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the shell-escaped string used to invoke the gdb subprocess.
This is a string that can be executed directly in a shell.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_subprocess_cmd(self):
    &#34;&#34;&#34;Returns the shell-escaped string used to invoke the gdb subprocess.
    This is a string that can be executed directly in a shell.
    &#34;&#34;&#34;
    return &#34; &#34;.join(quote(c) for c in self.cmd)</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.interrupt_gdb"><code class="name flex">
<span>def <span class="ident">interrupt_gdb</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Send SIGINT (interrupt signal) to the gdb subprocess</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def interrupt_gdb(self):
    &#34;&#34;&#34;Send SIGINT (interrupt signal) to the gdb subprocess&#34;&#34;&#34;
    self.send_signal_to_gdb(&#34;SIGINT&#34;)</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.send_signal_to_gdb"><code class="name flex">
<span>def <span class="ident">send_signal_to_gdb</span></span>(<span>self, signal_input)</span>
</code></dt>
<dd>
<section class="desc"><p>Send signal name (case insensitive) or number to gdb subprocess
gdbmi.send_signal_to_gdb(2)
# valid
gdbmi.send_signal_to_gdb('sigint')
# also valid
gdbmi.send_signal_to_gdb('SIGINT')
# also valid</p>
<p>raises ValueError if signal_input is invalie
raises NoGdbProcessError if there is no gdb process to send a signal to</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def send_signal_to_gdb(self, signal_input):
    &#34;&#34;&#34;Send signal name (case insensitive) or number to gdb subprocess
    gdbmi.send_signal_to_gdb(2)  # valid
    gdbmi.send_signal_to_gdb(&#39;sigint&#39;)  # also valid
    gdbmi.send_signal_to_gdb(&#39;SIGINT&#39;)  # also valid

    raises ValueError if signal_input is invalie
    raises NoGdbProcessError if there is no gdb process to send a signal to
    &#34;&#34;&#34;
    try:
        signal = int(signal_input)
    except Exception:
        signal = SIGNAL_NAME_TO_NUM.get(signal_input.upper())

    if not signal:
        raise ValueError(
            &#39;Could not find signal corresponding to &#34;%s&#34;&#39; % str(signal)
        )

    if self.gdb_process:
        os.kill(self.gdb_process.pid, signal)
    else:
        raise NoGdbProcessError(
            &#34;Cannot send signal to gdb process because no process exists.&#34;
        )</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.spawn_new_gdb_subprocess"><code class="name flex">
<span>def <span class="ident">spawn_new_gdb_subprocess</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Spawn a new gdb subprocess with the arguments supplied to the object
during initialization. If gdb subprocess already exists, terminate it before
spanwing a new one.
Return int: gdb process id</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def spawn_new_gdb_subprocess(self):
    &#34;&#34;&#34;Spawn a new gdb subprocess with the arguments supplied to the object
    during initialization. If gdb subprocess already exists, terminate it before
    spanwing a new one.
    Return int: gdb process id
    &#34;&#34;&#34;
    if self.gdb_process:
        self.logger.debug(
            &#34;Killing current gdb subprocess (pid %d)&#34; % self.gdb_process.pid
        )
        self.exit()

    self.logger.debug(&#39;Launching gdb: &#34;%s&#34;&#39; % &#34; &#34;.join(self.cmd))

    # Use pipes to the standard streams
    self.gdb_process = subprocess.Popen(
        self.cmd,
        shell=False,
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
        stderr=subprocess.PIPE,
        bufsize=0,
    )

    _make_non_blocking(self.gdb_process.stdout)
    _make_non_blocking(self.gdb_process.stderr)

    # save file numbers for use later
    self.stdout_fileno = self.gdb_process.stdout.fileno()
    self.stderr_fileno = self.gdb_process.stderr.fileno()
    self.stdin_fileno = self.gdb_process.stdin.fileno()

    self.read_list = [self.stdout_fileno, self.stderr_fileno]
    self.write_list = [self.stdin_fileno]

    # string buffers for unifinished gdb output
    self._incomplete_output = {&#34;stdout&#34;: None, &#34;stderr&#34;: None}
    return self.gdb_process.pid</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.verify_valid_gdb_subprocess"><code class="name flex">
<span>def <span class="ident">verify_valid_gdb_subprocess</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Verify there is a process object, and that it is still running.
Raise NoGdbProcessError if either of the above are not true.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def verify_valid_gdb_subprocess(self):
    &#34;&#34;&#34;Verify there is a process object, and that it is still running.
    Raise NoGdbProcessError if either of the above are not true.&#34;&#34;&#34;
    if not self.gdb_process:
        raise NoGdbProcessError(&#34;gdb process is not attached&#34;)

    elif self.gdb_process.poll() is not None:
        raise NoGdbProcessError(
            &#34;gdb process has already finished with return code: %s&#34;
            % str(self.gdb_process.poll())
        )</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, mi_cmd_to_write, timeout_sec=1, raise_error_on_timeout=True, read_response=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mi_cmd_to_write</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>String to write to gdb. If list, it is joined by newlines.</dd>
<dt><strong><code>timeout_sec</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum number of seconds to wait for response before exiting. Must be &gt;= 0.</dd>
<dt><strong><code>raise_error_on_timeout</code></strong> :&ensp;<code>bool</code></dt>
<dd>If read_response is True, raise error if no response is received</dd>
<dt><strong><code>read_response</code></strong> :&ensp;<code>bool</code></dt>
<dd>Block and read response. If there is a separate thread running,</dd>
</dl>
<p>this can be false, and the reading thread read the output.</p>
<h2 id="returns">Returns</h2>
<p>List of parsed gdb responses if read_response is True, otherwise []</p>
<h2 id="raises">Raises</h2>
<p>NoGdbProcessError if there is no gdb subprocess running
TypeError if mi_cmd_to_write is not valid</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write(
    self,
    mi_cmd_to_write,
    timeout_sec=DEFAULT_GDB_TIMEOUT_SEC,
    raise_error_on_timeout=True,
    read_response=True,
):
    &#34;&#34;&#34;Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec.

    Args:
        mi_cmd_to_write (str or list): String to write to gdb. If list, it is joined by newlines.
        timeout_sec (float): Maximum number of seconds to wait for response before exiting. Must be &gt;= 0.
        raise_error_on_timeout (bool): If read_response is True, raise error if no response is received
        read_response (bool): Block and read response. If there is a separate thread running,
        this can be false, and the reading thread read the output.
    Returns:
        List of parsed gdb responses if read_response is True, otherwise []
    Raises:
        NoGdbProcessError if there is no gdb subprocess running
        TypeError if mi_cmd_to_write is not valid
    &#34;&#34;&#34;
    self.verify_valid_gdb_subprocess()
    if timeout_sec &lt; 0:
        self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
        timeout_sec = 0

    # Ensure proper type of the mi command
    if type(mi_cmd_to_write) in [str, unicode]:
        pass
    elif type(mi_cmd_to_write) == list:
        mi_cmd_to_write = &#34;\n&#34;.join(mi_cmd_to_write)
    else:
        raise TypeError(
            &#34;The gdb mi command must a be str or list. Got &#34;
            + str(type(mi_cmd_to_write))
        )

    self.logger.debug(&#34;writing: %s&#34;, mi_cmd_to_write)

    if not mi_cmd_to_write.endswith(&#34;\n&#34;):
        mi_cmd_to_write_nl = mi_cmd_to_write + &#34;\n&#34;
    else:
        mi_cmd_to_write_nl = mi_cmd_to_write

    if USING_WINDOWS:
        # select not implemented in windows for pipes
        # assume it&#39;s always ready
        outputready = [self.stdin_fileno]
    else:
        _, outputready, _ = select.select([], self.write_list, [], timeout_sec)
    for fileno in outputready:
        if fileno == self.stdin_fileno:
            # ready to write
            self.gdb_process.stdin.write(mi_cmd_to_write_nl.encode())
            # don&#39;t forget to flush for Python3, otherwise gdb won&#39;t realize there is data
            # to evaluate, and we won&#39;t get a response
            self.gdb_process.stdin.flush()
        else:
            self.logger.error(&#34;got unexpected fileno %d&#34; % fileno)

    if read_response is True:
        return self.get_gdb_response(
            timeout_sec=timeout_sec, raise_error_on_timeout=raise_error_on_timeout
        )

    else:
        return []</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbTimeoutError"><code class="flex name class">
<span>class <span class="ident">GdbTimeoutError</span></span>
<span>(</span><span><small>ancestors:</small> builtins.ValueError, builtins.Exception, builtins.BaseException)</span>
</code></dt>
<dd>
<section class="desc"><p>Raised when no response is recieved from gdb after the timeout has been triggered</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class GdbTimeoutError(ValueError):
    &#34;&#34;&#34;Raised when no response is recieved from gdb after the timeout has been triggered&#34;&#34;&#34;

    pass</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.NoGdbProcessError"><code class="flex name class">
<span>class <span class="ident">NoGdbProcessError</span></span>
<span>(</span><span><small>ancestors:</small> builtins.ValueError, builtins.Exception, builtins.BaseException)</span>
</code></dt>
<dd>
<section class="desc"><p>Raise when trying to interact with gdb subprocess, but it does not exist.
It may have been killed and removed, or failed to initialize for some reason.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NoGdbProcessError(ValueError):
    &#34;&#34;&#34;Raise when trying to interact with gdb subprocess, but it does not exist.
    It may have been killed and removed, or failed to initialize for some reason.&#34;&#34;&#34;

    pass</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygdbmi" href="index.html">pygdbmi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pygdbmi.gdbcontroller.GdbController" href="#pygdbmi.gdbcontroller.GdbController">GdbController</a></code></h4>
<ul class="">
<li><code><a title="pygdbmi.gdbcontroller.GdbController.__init__" href="#pygdbmi.gdbcontroller.GdbController.__init__">__init__</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.exit" href="#pygdbmi.gdbcontroller.GdbController.exit">exit</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.get_gdb_response" href="#pygdbmi.gdbcontroller.GdbController.get_gdb_response">get_gdb_response</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.get_subprocess_cmd" href="#pygdbmi.gdbcontroller.GdbController.get_subprocess_cmd">get_subprocess_cmd</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.interrupt_gdb" href="#pygdbmi.gdbcontroller.GdbController.interrupt_gdb">interrupt_gdb</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.send_signal_to_gdb" href="#pygdbmi.gdbcontroller.GdbController.send_signal_to_gdb">send_signal_to_gdb</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.spawn_new_gdb_subprocess" href="#pygdbmi.gdbcontroller.GdbController.spawn_new_gdb_subprocess">spawn_new_gdb_subprocess</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.verify_valid_gdb_subprocess" href="#pygdbmi.gdbcontroller.GdbController.verify_valid_gdb_subprocess">verify_valid_gdb_subprocess</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.write" href="#pygdbmi.gdbcontroller.GdbController.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygdbmi.gdbcontroller.GdbTimeoutError" href="#pygdbmi.gdbcontroller.GdbTimeoutError">GdbTimeoutError</a></code></h4>
</li>
<li>
<h4><code><a title="pygdbmi.gdbcontroller.NoGdbProcessError" href="#pygdbmi.gdbcontroller.NoGdbProcessError">NoGdbProcessError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>